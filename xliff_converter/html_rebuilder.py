"""
HTML document rebuilder module

Restores a translated HTML document from a XLIFF file generated by
``html_parser.py``.
"""
import os
import re
from base64 import b64decode
from html import unescape
from collections import namedtuple
from xml.dom.minidom import parseString, Element, Text

__all__ = ['rebuild_html']

Translation = namedtuple(
    'Translation',
    ['filename', 'target_language', 'skeleton', 'segments']
)
HtmlDocument = namedtuple('HtmlDocument', ['filename', 'html'])

html_lang_re = re.compile(r'<html\s+?lang=["\'][\w-]+["\']>', re.I)
http_equiv_lang_re = re.compile(
    r'<meta\s+?http-equiv=["\']content-language["\']\s+?value=["\'][\w-]+["\']\s*?/?>',
    re.I
)


class InvalidXliffError(Exception):
    pass


def extract_text(element):
    """

    :param element:
    :return:
    """
    text = ''
    for child in element.childNodes:
        if isinstance(child, Text):
            text += child.data
        elif isinstance(child, Element):
            text += unescape(child.firstChild.data)
    return text


def extract_translation(xliff, strict=True):
    """
    Extract translation from a XLIFF 1.2. document

    :param xliff: translated XLIFF document
    :type xliff: str
    :param strict: if ``True`` exception will be raised on a missing translation.
        If ``False`` source text will be used instead of a missing translation.
    :type strict: bool
    :return: extracted translation data
    :rtype: Translation
    :raises InvalidXliffError: if a segment is not translated
        in strict extraction mode, or if XLIFF is missing ``target-language``
        property.
    """
    doc = parseString(xliff)
    file_elem = doc.getElementsByTagName('file')[0]
    filename = file_elem.getAttribute('original')
    target_language = file_elem.getAttribute('target-language')
    if not target_language:
        raise InvalidXliffError('XLIFF has no target language specified!')
    name, ext = os.path.splitext(filename)
    filename = name + '_' + target_language + ext
    internal_file_elem = doc.getElementsByTagName('internal_file')[0]
    skeleton = b64decode(
        internal_file_elem.firstChild.data.encode('ascii')
    ).decode('utf-8')
    trans_units = doc.getElementsByTagName('trans-unit')
    segments = []
    for tu in trans_units:
        try:
            trans_elem = tu.getElementsByTagName('target')[0]
        except IndexError:
            if strict:
                raise InvalidXliffError(
                    'Missing translation for segment #{}'.format(
                        tu.getAttribute('id')
                    )
                )
            trans_elem = tu.getElementsByTagName('source')[0]
        segments.append(extract_text(trans_elem))
    return Translation(filename, target_language, skeleton, segments)


def restore_skeleton(skeleton, segments):
    """
    Restore translated HTML from a skeleton

    :param skeleton: HTML skeleton
    :type skeleton: str
    :param segments: translated segments
    :type segments: list
    :return: translated HTML
    :rtype: str
    """
    for i, seg in enumerate(segments, 1):
        skeleton = skeleton.replace('{{{{%{}%}}}}'.format(i), seg)
    return skeleton


def set_language(html, target_lang):
    """
    Set target language property in HTML

    :param html:
    :type html: str
    :param target_lang:
    :type target_lang: str
    :return:
    :rtype: str
    """
    html_lang_match = html_lang_re.search(html)
    if html_lang_match is not None:
        html = html_lang_re.sub(
            '<html lang="{}">'.format(target_lang.lower()),
            html
        )
        return html
    http_equiv_lang_match = http_equiv_lang_re.search(html)
    if http_equiv_lang_match is not None:
        html = http_equiv_lang_re.sub(
            '<meta http-equiv="content-language" value="{}">'.format(
                target_lang.lower()
            ),
            html
        )
        return html
    # No html language definition found, we need to add it ourselves
    return html.replace('<html>', '<html lang="{}">'.format(target_lang.lower()))


def rebuild_html(xliff, strict=True):
    """
    Rebuild translated HTML

    :param xliff: translated XLIFF document
    :type xliff: str
    :param strict: if ``True`` exception will be raised on a missing translation.
        If ``False`` source text will be used instead of a missing translation.
    :type strict: bool
    :return: translated HTML document
    :rtype: HtmlDocument
    """
    translation = extract_translation(xliff, strict)
    html = restore_skeleton(translation.skeleton, translation.segments)
    html = set_language(html, translation.target_language)
    return HtmlDocument(translation.filename, html)
